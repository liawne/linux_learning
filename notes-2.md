---------
学习Linux 学的是其中各种方式实现的思想|
--

## understanding the linux operating system   ##2018-04-09##
1、OS：operating system本身就是一个虚拟机  
2、计算机构成：五大部分

    CPU：
         运算器：负责运算，算数运算、逻辑运算
         控制器：控制指令，数据的存取过程
         寄存器：CPU计算数据来源及计算结果暂存位置（register）
3、程序就是指令加数据构成的  
4、CPU与内存的沟通（CPU、north bridge、RAM）

    a、理解为CPU通过桥（总线）连接到North bridge，North bridge在通过桥（总线）连接到RAM;桥的宽度可以是32bit、64bit
       桥的宽度影响CPU能够寻址的大小，32bit时为2^32=4GB大小;64bit时为4G×4GB大小。
    b、CPU的控制指令、数据存取都是通过这个32bit、64bit，也即是线路复用的情况
5、PAE：物理地址扩展physical address extension

    作用：为32位的寻址总线加上了4bit;32bit，+4bit;增加了该功能够，使本身只支持4G的系统可以支持4GB×16=64GB
6、缓存的使用

    a、程序：局部性
    b、CPU的缓存：指令缓存，数据缓存;一级缓存、二级缓存各cpu独有，三级缓存一般是共享的;缓存的大小会影响系统性能
    c、对于ram存取数据来说，保存有数据实际上就是ram中带有电荷，读取完成之后，电荷就消失了;ram需要不停的刷新来存取数据
7、缓存的置换策略

    a、空间局部性：一个数据被使用到，则其旁边的数据被用到的概率更大
    b、时间局部性：一个数据如果被用到，那他再次被用到的概率更大
8、若CPU有输出，有数据被更改，则可能对一级缓存、二级缓存、三级缓存、主存、硬盘都要进行写操作，这种方式称为通写（write through）;  
9、若CPU有输出，有数据被更改，但是没有立即写入到各层级存储中去，只有数据在被丢弃的时候才写入后面的存储，这种方式称为回写（write back）;目前绝大多数情况都是回写的方式，性能相对而言高了很多;  
10、一般情况下，显卡也是直接接到North bridge上的，需要使用到CPU对图像进行渲染和计算，数据交换量是非常大的;  
11、IO分为高速IO和低速IO

    a、高速IO一般是指PCI的IO，高速IO总线
    b、南桥一般是把慢速IO汇总起来，一并交给北桥进行处理
    c、PCI是连接到南桥的，速度其实不能算是很快;现有PCI-E口，直接接到北桥上，速度比PCI口快了不止一点点;
    d、使用PCI-E口的USB速度会很快，带宽足够了，瓶颈可能变成了USB的读写能力，这个时候可以将多个USB设备整合成为一个存储
        设备，并行读写，这种方式就是固态硬盘的方式;仍有选择使用PCI（SATA）口的固态硬盘，建议用PCI-E口的固态硬盘;
12、各种设备连接到南桥，南桥在连接到北桥，北桥在连接到CPU;北桥和内存又相连;北桥给各种不同的设备分配地址（32bit/64bit）用做CPU来区分和识别 

    a、任何一个设备，为了能够和主机交互，在加电自检完成之后，每一个硬件都必须向CPU注册申请整个IO端口上一片连续的端口;
        每一次注册的结果可能不一样;在开启后，CPU与这些设备交互都是通过这些端口来进行;
    b、虽然各个设备已经注册了不同的端口与CPU交互，但仍然还是通过同一个总线进行 --> 总线复用
    c、没一个硬件设备的内部线路可能与CPU不一致，但都会有各自的控制器（适配器），作用是将这个设备能够理解的信号转换成
        总线上能够识别的信号，是个翻译官，还可能附带是司令官，控制校验，速率设定等;
13、（可编程）中断控制器（Interrupt Controller）

    a、CPU上自带有一个中断控制器，用于接收处理中断信号的;
    b、当硬件设备上来了信号之后（区别于IO端口），由这个硬件设备负责通知CPU（中断控制器）进行处理;
    c、中断控制器帮助CPU识别是哪个硬件发过来的中断请求;中断控制器上有中断控制线（中断通路）;
    d、硬件发送过来的中断信号，也即是中断向量 
    e、每一个硬件设备在启动的时候，必须要向中断控制器（可编程中断控制器）来申请注册使用一个中断向量 --> 有地址
        的通知机制;当信号发送过来后，能够自动被CPU识别，即认识到是哪个硬件设备发送过来的。
    f、一般将中断处理分为上半部和下半部;上半部，将请求接近来;下半部，处理中断请求。
14、直接内存访问DMA（direct memory access）

    a、cpu将数据从磁盘中读取写入的操作授权给其他助手使用（总线的使用），可能出现资源争抢的情况，容易出现争抢现象的
        位置称为临界区
    b、CPU告诉DMA有15M可以读取，将线路授权给DMA;DMA没有CPU那么打的总线带宽，一般系统会预留低地址的内存给DMA
        使用（寻址限制）
15、BIOS自举

    a、系统启动之后，系统会将ROM空间内容映射到内存最开始的部分
    b、CPU加电后，什么事都不干，先执行内存最初始部分的代码，完成自检，加载bootloader
    c、内存的空间分配为ROM：DMA：left
16、系统启动之后，CPU一直处于运行状态，区别只是有用的转和无用的转，运行称为时钟周期

    a、CPU内部通常有一个称为时钟产生器的东西（晶体震荡器）
    b、内存可能在一个CPU的时钟周期内只走了一点点
    c、CPU以时间片来进行资源的利用和分配，通过时间的流逝来体现计算能力
17、操作系统的演变（所有的程序运行都要向监控程序申请资源）

    a、有一个管理系统（管理程序），负责从磁盘中加载一个程序到内存中，然后加载程序到CPU进行运算，运算结果保存到内存
        中，再把数据写回到硬盘;再加载另一个程序来运行，周而复始;这个程序早期叫做monitor，就是一个监控程序，其他程序的
        监控程序
    b、程序发展得越来越大，变成了OS（operating system）
    c、OS把整个机器抽象出来，变成了一个虚拟机VM（virtual machine）
18、process：进程，一个独立的运行单位

    a、进程无法直接在硬件上运行，由监控程序（OS）来监控运行
    b、系统资源：CPU时间、存储空间
19、OS：VM

        a、CPU：站在CPU的角度，以时间来进行区分
            1、时间：切片来进行;一个10GHz的CPU可以虚拟看成是10个1GHz的虚拟CPU
            2、缓存：缓存当前程序数据，在数据清空前需要进行回写
            3、指令计数器：CPU当中包含的，当前的进程分配的时间用完了，但是进程仍未执行完，下次怎么继续处理呢，依赖于
                            指令计数器来实现
            4、进程切换：进程切换的时候要保留现场，恢复现场;进程切换是有开销的，如缓存在切换的过程中被清掉了，恢复现场
                            的时候则需要重新加载数据，保存现场的数据保存在主存当中
        b、MEM：站在内存的角度，以空间大小来进行区分，同样还是切片
            1、内存的实现方式为：将内存切割，分成4K大小的存储槽，每个存储槽称作一个页框;每个槽能够存储的数据称为一个
                页面（page），每一个页面的存储空间称为一个页框（page frame），在页框上增加一个页框和页的映射关系;
            2、每一个进程都认为自己是有4G空间可用的
                a、内存空间的分配：指令区（代码区），数据区，bss段，heap区 <--> stack区
                                   --------------  | ----- | ---- | ----- |    |------- --> 4G大小
                                   只使用了有限的空间，中间为空
                   以上面的为例解释，假设指令区一个页，数据区一个页，bss一个页，heap一个页，stack一个页;通过映射，指
                   令区映射到一个页框，数据区映射到一个页框，bss映射到一个页框，heap映射到一个页框，stack映射到一个
                   页框（不一定连续）
                b、虚拟出来的空间可以认为是一个进程描述结构
                c、这个是有内核在内存中维护的，当进程需要使用时，内核告诉进程相应的映射关系
                d、页目录，映射关系由一个芯片负责维护，在进程需要使用到自己的数据时，怎么样能够更快的找到虚拟地址（线
                    性地址）实际对应的物理地址呢;通过页目录来实现的，页目录分为一级、二级、三级。。来实现更高效率的
                    查找;用于方便建立线性地址到物理地址的对应关系
                e、通过空间映射来完成
                f、实现映射关系的芯片的引入还同时具有了内存保护的功能
         c、IO设备：在进程层次上，IO设备不需要去做虚拟，IO设备在谁获得了当前的焦点，IO对应的切换就交给哪个进程了
            1、IO只能是内核控制，一旦产生IO中断，一定是和内核交互，再由内核转给进程
            2、内核，N×进程 --> 系统
                a、内核运行时，是内核模式
                b、进程运行时，是用户模式
                c、在内存当中，内核占用空间是内核空间，进程占用空间是用户空间
                d、进程是不能直接控制硬件的
20、早期x86架构的系统是不适合用来做虚拟机的，在后来CPU支持硬件虚拟化之后才实现了

    a、在进程的层次上，资源已经被虚拟化过一次了
21、CPU指令分为四个层级，环0-3,环0为内核模式（特权模式），环3是用户模式（限制模式）  
22、虚拟机的运行模式有多种，其中一种是仿真（模拟）出来硬件层，在虚拟机系统层面查看不出来是否是在虚拟机上运行

    a、这种模式下，虚拟机上的内核运行特权指令时是通过虚拟机先翻译传给物理机内核，内核处理完再返还
    b、在后来更改了一种机制，物理机上增加环-1（包含最最特权的指令），虚拟机可以运行环0的指令（不包含一些特权指令）
        硬件虚拟化也就是提供了-1环
23、IO准备的过程

    a、进程空间交接给内核空间
    b、内核开始调用，将辅存当中的数据读取出来，先放到内核空间的缓存中
    c、内核空间缓存转移到用户空间缓存中
    d、地址映射，物理内存映射完成
    e、资源准备完成，内核唤醒进程
24、进程队列

    a、就绪状态，sleeping状态（可中断、不可中断）

## understanding the linux operating system two   ##2018-04-16##
1、操作系统、硬件、软件结构图

     ----------------------------------------------------
    |                     Applications                   |
    |---------------------------                         |
    |       Libraries           |                        |
    |----------------------------------------------------|
    |                                                    |
    |         Kernel            -------------------------|
    |                           |            Drivers     |
    |            --------------------------              |  
    |            |       Firmware         |              |
    |----------------------------------------------------|
    |                  Hardware                          |
     ----------------------------------------------------
2、在linux中，进程是通过双向链表（list）来进行管理组织的

    a、进程描述符：没一个进程都有其进程描述符 
    b、在创建一个进程的时候，首先一步就是要创建一个进程描述符，并将其添加到双向链表上
    c、杀掉一个进程，就是将这个进程描述符删除，内核不在能够追踪此描述符
    d、创建了一个进程后除了给进程分配CPU、内存等资源外，还需要在内核的内存空间中维护一个进程描述符文件，里面保存有进程
        当前的所有相关信息
3、task_struct（进程描述）

      task_struct
     --------------
    |status
    |--------------
    |thread_info
    |--------------
    |usage
    |flags
    |...
    |--------------
    |run_list
    |
    |tasks
    |--------------
    |...                    mm_struct
    |--------------        --------------------
    |mm            -----> | pointers to memory |
    |--------------       | aera descriptors   |
    |                      --------------------
    |--------------
    |real_parent
    |parent
    |--------------
    |...
    |--------------
    |tty           -----> ...
    |--------------
    |...
    |--------------
    |thread        -----> ...
    |--------------
    |...
    |-------------
    |fs            -----> ...
    |--------------
    |files         -----> ...
    |-------------
    |
    |-------------
    |signals
    |pending
    |-------------
    |
     -------------
4、进程切换

    a、进程切换也称为上下文切换（context switch）
    b、进程A切换至进程B，A挂起，称为保存现场;B恢复，称为恢复现场
    c、进程切换由内核进行管控;每次进程切换都需要经过内核，进程由用户模式切换至内核模式，内核模式在切换回用户模式
    d、进程切换需要时间，分为用户模式需要占用的时间和内核模式需要占用的时间（分别对应top中的sys和usr）
    e、进程切换太多不好（内核模式占用时间多，用于处理事件的用户模式占用时间就少了）;进程切换太少也不好（10个进程，
        每个进程等待时间过长，影响用户体验）
    f、linux支持进程抢占，linux有自己内部的系统时钟：tick（滴答），每一次tick即可产生一次时钟中断
5、linux中进程分类

    a、交互式进程（IO密集型，等待IO）：桌面型优先级相对高一些
    b、批处理进程（CPU密集型）：服务器型优先级相对高一些
    c、实时进程（real-time）：优先级特别高
    d、分配策略：为CPU密集型进程设定时间片长，优先级低;为IO密集型设定CPU时间片短，优先级高
6、linux优先级

    a、实时优先级：1-99,数字越小，优先级越低
    b、静态优先级：100-139,数字越小，优先级越高
    c、实时优先级比静态优先级高
    d、在top的输出结果中，表头显示PR（priority）的列中出现RT表示real time;riprio（实时优先级）
    e、在top命令的输出结果中comm列包含[]的命令表示为内核线程
7、linux调度类别

    a、实时进程：
        1、SCHED_FIFO：First In First Out
        2、SCHED_RR  ：Round Robin
        3、SCHED_OTHER：用来调度100-139的进程
    b、在top命令输出结果中的CLASS列表示的是该进程的调度类别
    c、动态优先级：在内核当中，若某个进程长时间为被运行，内核会临时性的调高其优先级
    d、chrt命令用来调整1-99的进程，nice/renice用于调整100-139的进程
        1、chrt -f -p prio pid ：fifo
        2、chrt -r -p prio pid ：rr
8、优先级算法O（1）

    2.6的内核使用方式为划分为1-139共140×2=280个队列（每个级别有两个队列，一个是活动队列，一个是过期队列），
    将每个级别的进程分别加入各自对应的队列，每次需要选择进程进行执行，扫描队列的首部即可

## understanding the linux operating system three   ##2018-04-16##
1、中断

    a、硬中断：硬件产生的中断
    b、软中断：由用户空间进入到内核空间
2、CPU缓存

    a、一级缓存有两个，分别是I1（指令缓存），D1（数据缓存）
3、SMP对称多处理器：在一个主板上有多个cpu插槽，每一个插槽称为一个socket

    a、完成一次正常的内存访问，CPU至少需要三个时钟周期，分别是
        1、向内存控制器传输一个寻址要求
        2、完成地址确定后（内存地址的编址是由内存控制器来完成的），CPU找到内存地址并施加一定的请求机制（对内存施加锁）
        3、完成读或者写的操作
    b、内存节点只有一个，性能的提升是有限的（增加CPU），在于内存的争用